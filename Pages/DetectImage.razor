@page "/detectimage"
@using Microsoft.ML
@using Microsoft.ML.Data
@using Microsoft.ML.OnnxRuntime
@using Microsoft.ML.OnnxRuntime.Tensors
@using Microsoft.ML.Transforms.Onnx
@using System.IO;
@using Microsoft.AspNetCore.Components.Forms
@using SixLabors.ImageSharp;
@using SixLabors.ImageSharp.PixelFormats;
@using SixLabors.ImageSharp.Formats.Png;
@using SixLabors.ImageSharp.Processing
@inject IWebHostEnvironment Env

<h3>Comparer 2 images</h3>

<InputFile OnChange="OnInputFile1" />
<InputFile OnChange="OnInputFile2" />

<div style="display: flex; gap: 20px; align-items: flex-start;">
    <div style="text-align: center;">
        <div><strong>Image 1</strong></div>
        <p>@img1Error</p>
        @if (img1Preview != null)
        {
            <img src="@img1Preview" width="200" style="border: 1px solid #ccc; border-radius: 5px;" />
        }
    </div>

    <div style="text-align: center;">
        <div><strong>Image 2</strong></div>
        <p>@img2Error</p>
        @if (img2Preview != null)
        {
            <img src="@img2Preview" width="200" style="border: 1px solid #ccc; border-radius: 5px;" />
        }
    </div>

    <div style="text-align: center;">
        <button @onclick="CompareImagesWithOnnx" disabled="@(!CanCompare)">Comparer</button>
    </div>
</div>



@if (similarity.HasValue)
{
    <div style="text-align: center;">
        <p><b>Similarité : @similarity.Value.ToString("0.00") %</b></p>
    </div>
}

@code {
    private IBrowserFile file1, file2;
    private string? img1Preview, img2Preview;
    private string? img1Error, img2Error;
    private float? similarity;

    private bool CanCompare => file1 != null && file2 != null && string.IsNullOrEmpty(img1Error) && string.IsNullOrEmpty(img2Error);


    private async Task OnInputFile1(InputFileChangeEventArgs e)
    {
        try
        {
            img1Error = null;
            file1 = e.File;
            img1Preview = await ConvertToBase64Async(file1);
        }
        catch (Exception ex)
        {
            img1Error = $"{ex.Message}";
        }
    }

    private async Task OnInputFile2(InputFileChangeEventArgs e)
    {
        try
        {
            img2Error = null;
            file2 = e.File;
            img2Preview = await ConvertToBase64Async(file2);
        }
        catch (Exception ex)
        {
            img2Error = $"{ex.Message}";
        }
    }

    private async Task CompareImages()
    {
        var tempFile1 = await SaveBrowserFile(file1);
        var tempFile2 = await SaveBrowserFile(file2);

        var mlContext = new MLContext();

        // Charger le modèle ONNX
        var pipeline = mlContext.Transforms
                        .LoadImages(outputColumnName: "input", imageFolder: "", inputColumnName: nameof(ImageInput.Image))
                        .Append(mlContext.Transforms.ResizeImages("input", 224, 224))
                        .Append(mlContext.Transforms.ExtractPixels(
                            outputColumnName: "image_tensor", // correspond au nom attendu par le modèle
                            inputColumnName: "input"))
                        .Append(mlContext.Transforms.ApplyOnnxModel(
                            modelFile: Path.Combine(Env.WebRootPath, "models/MobileNet-v2.onnx"),
                            outputColumnNames: new[] { "class_logits" },
                            inputColumnNames: new[] { "image_tensor" }));

        var model = pipeline.Fit(mlContext.Data.LoadFromEnumerable(new List<ImageInput>()));

        // Convertir les images en float[] via ML.NET
        var engine = mlContext.Model.CreatePredictionEngine<ImageInput, ImageOutput>(model);

        var img1Data = new ImageInput { Image = tempFile1 };
        var img2Data = new ImageInput { Image = tempFile2 };

        var feat1 = engine.Predict(img1Data).Output;
        var feat2 = engine.Predict(img2Data).Output;

        similarity = CosineSimilarity(feat1, feat2) * 100;
    }

    private async Task<string> SaveBrowserFile(IBrowserFile file)
    {
        var tempPath = Path.Combine(Path.GetTempPath(), file.Name); // nom du fichier temporaire
        using var fs = File.Create(tempPath);
        await file.OpenReadStream().CopyToAsync(fs);
        return tempPath;
    }

    public class ImageInput
    {
        public string Image { get; set; } = null!;
    }

    public class ImageOutput
    {
        [ColumnName("class_logits")]
        public float[] Output { get; set; } = null!;
    }


    private float CosineSimilarity(float[] a, float[] b)
    {
        float dot = 0;
        float magA = 0;
        float magB = 0;
        for (int i = 0; i < a.Length; i++)
        {
            dot += a[i] * b[i];
            magA += a[i] * a[i];
            magB += b[i] * b[i];
        }
        return dot / ((float)Math.Sqrt(magA) * (float)Math.Sqrt(magB));
    }

    private async Task<string> ConvertToBase64Async(IBrowserFile file)
    {
        try
        {
            using var stream = file.OpenReadStream(maxAllowedSize: 10_000_000);
            using var image = await Image.LoadAsync<Rgba32>(stream);

            using var ms = new MemoryStream();
            await image.SaveAsync(ms, new PngEncoder());

            return $"data:image/png;base64,{Convert.ToBase64String(ms.ToArray())}";
        }
        catch (Exception ex)
        {
            throw new Exception(ex.Message);
        }
    }


    ////////////////////
    private DenseTensor<float> PreprocessImage(string imagePath)
    {
        using var image = Image.Load<Rgb24>(imagePath);
        image.Mutate(x => x.Resize(224, 224));

        var tensor = new DenseTensor<float>(new[] { 1, 3, 224, 224 });

        float[] mean = { 0.48145466f, 0.4578275f, 0.40821073f };
        float[] std = { 0.26862954f, 0.26130258f, 0.27577711f };

        for (int y = 0; y < 224; y++)
        {
            for (int x = 0; x < 224; x++)
            {
                var p = image[x, y];
                tensor[0, 0, y, x] = (p.R / 255f - mean[0]) / std[0];
                tensor[0, 1, y, x] = (p.G / 255f - mean[1]) / std[1];
                tensor[0, 2, y, x] = (p.B / 255f - mean[2]) / std[2];
            }
        }

        return tensor;
    }

    private async Task CompareImagesWithOnnx()
    {
        var file1Path = await SaveBrowserFile(file1);
        var file2Path = await SaveBrowserFile(file2);

        string modelPath = Path.Combine(Env.WebRootPath, "models/openai.clip-vit-base-patch32.onnx");

        using var session = new InferenceSession(modelPath);

        var tensor1 = PreprocessImage(file1Path);
        var tensor2 = PreprocessImage(file2Path);

        var inputs1 = new List<NamedOnnxValue> { NamedOnnxValue.CreateFromTensor("pixel_values", tensor1) };
        var inputs2 = new List<NamedOnnxValue> { NamedOnnxValue.CreateFromTensor("pixel_values", tensor2) };

        using var results1 = session.Run(inputs1);
        using var results2 = session.Run(inputs2);

        var logits1 = results1.First().AsEnumerable<float>().ToArray();
        var logits2 = results2.First().AsEnumerable<float>().ToArray();

        similarity = CosineSimilarity(logits1, logits2) * 100;
    }
}